<!DOCTYPE html>
<meta charset="utf-8">
<style>

.hexagon {
  fill: white;
  pointer-events: all;
}

.hexagon path {
  -webkit-transition: fill 250ms linear;
  transition: fill 250ms linear;
}

.hexagon :hover {
  fill: pink;
}

.hexagon .fill {
  fill: red;
}

.mesh {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
  pointer-events: none;
}

.border {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
  pointer-events: none;
}

</style>
<body>
	<input type="range" name="beans" id="beans" min="0" max="659" step="1" value="0">
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-latest.js"></script>
<script>

var color_arr = [];
var temp_num = 0;

for (var i = 0; i < 30; i++)
{
	for (var j = 0; j <= 33; j++)
	{
		color_arr.push({"x_axis": i, "y_axis": j, "value": 0})
	}
}

d3.csv("static/data/sid.csv", function(sid) {
	d3.json("static/data/sid_peoplecount.json", function(count){
	  	var num = 0;

	  	var time = 0;

	  	for (var key in count[time])
	  	{
	  		if (key != "time")
	  		{
	  			color_arr[parseInt(sid[num].x_axis) * 34 + parseInt(sid[num].y_axis)].value = count[time][key];
	  		}
	  		num++;
	  	}

	  	var width = 1550,
		    height = 1200,
		    radius = 10;

		var topology = hexTopology(radius, width, height);

		var projection = hexProjection(radius);

		var path = d3.geoPath()
		    .projection(projection);

		//var myColor = d3.scaleLinear().domain([1,10]).range(d3.schemeReds[7]);

		var index_domain = [];

		for (var i = 1; i <= 5; i++)
		{
			index_domain.push(i);
		}

		var color_range = [];

		for (var i = 0; i <= 5; i++)
		{
			if (i == 0)
				color_range.push("white");
			else
			{
				color_range.push(d3.schemePaired[i]);
			}
		}

		var myColor = d3.scaleThreshold()
				  .domain(index_domain)
				  .range(color_range);

		console.log(topology);

		var svg = d3.select("body").append("svg")
		    .attr("id","heatmap")
		    .attr("width", width)
		    .attr("height", height);

		svg.append("g")
		    .attr("class", "hexagon")
		  .selectAll("path")
		    .data(topology.objects.hexagons.geometries)
		  .enter().append("path")
		    .attr("id", function(d){
		    	return "Square" + (d.x_axis * 34 + d.y_axis);
		    })
		    .attr("d", function(d) { return path(topojson.feature(topology, d)); })
		    .style("fill", function(d) { return myColor(d.value)} )
		    //.attr("class", function(d) { return d.fill ? "fill" : null; })
		    .on("mousedown", mousedown)
		    //.on("mousemove", mousemove)
		    .on("mouseup", mouseup);

		svg.append("path")
		    .datum(topojson.mesh(topology, topology.objects.hexagons))
		    .attr("class", "mesh")
		    .attr("d", path);

		var border = svg.append("path")
		    .attr("class", "border")
		    .call(redraw);

		d3.csv("static/data/day1.csv", function(list){
			//Draw line
			var line_data = [];
			var sid_data = [];

			var id = "11396";

			for (var i = 0; i < list.length; i++)
			{
				if (list[i].id == id)
				{
					sid_data.push(list[i].sid);
				}	
			}

			for (var i = 0; i < sid_data.length; i++)
			{
				for (var j = 0; j < sid.length; j++)
				{
					if (sid_data[i] == sid[j].sid)
					{
						line_data.push([sid[j].x_axis * 15 + 7.5, sid[j].y_axis * 15 - 7.5]);
						break;
					}
				}
			}

			//console.log(line_data);

			var line_data_arr = [];

			var temp = [];

			for (var i = 0; i < line_data.length-1; i++)
			{
				temp = [];
				temp.push(line_data[i]);
				temp.push(line_data[i+1]);
				line_data_arr.push(temp);
			}

			//console.log(line_data_arr);

			lineGenerator = d3.line()
	                      //    获取每个节点的x坐标
	                      .x(function(d) {
	                            return d[0]
	                        })
	                       //   获取每个节点的y坐标
	                       .y(function(d) {
	                            return d[1];
	                       });

	        for (var i = 0; i < line_data_arr.length; i++)
	        {
	        	if (i % line_data_arr.length == 0) var opac = '1';
	        	else opac = '0.1';

	        	svg.append('path')
	        		.attr("id", "indiv_line" + i.toString())
			        .attr('stroke', 'red')
			        .attr('stroke-width', '4')
			        .attr('fill', 'none')
			        //    设置路径信息
			        .attr('d', lineGenerator(line_data_arr[i]))
			        .attr('opacity', opac)
			}

	        window.setInterval(timecount,100);

	        function timecount(){
        		temp_num = temp_num % line_data_arr.length + 1;

        		console.log(temp_num);

		        for (var i = 0; i < line_data_arr.length; i++)
		        {
		        	if (i % line_data_arr.length == temp_num) var opac = '1';
		        	else opac = '0.1';

		        	d3.select("#indiv_line" + i.toString())
				        .attr('stroke', 'red')
				        .attr('stroke-width', '4')
				        .attr('fill', 'none')
				        //    设置路径信息
				        .attr('d', lineGenerator(line_data_arr[i]))
				        .attr('opacity', opac)
				}
	        }
		});

	    //Draw frame
	    var mousing = 0;

		change();

		//d3.select("#Square103").call(redraw);

		var select_square = [];

		var start_value, end_value, fill_value;

		//输出数组
		function mousedown(d) {
		  mousing = d.fill ? 0 : +1;
		  //mousemove.apply(this, arguments);
		  start_value = $(this).attr("id");
		  console.log(this);
		}

		/*function mousemove(d) {
		  if (mousing) {
		    d3.select(this).classed("fill", d.fill = mousing > 0);
		    border.call(redraw);
		  }
		}*/

		function mouseup() {
		  //mousemove.apply(this, arguments);
		  end_value = $(this).attr("id");
		  var min = Math.min(parseInt(start_value.substring(6,9)), parseInt(end_value.substring(6,9)));
		  var max = Math.max(parseInt(start_value.substring(6,9)), parseInt(end_value.substring(6,9)));
		  select_square = []
		  for (var i = Math.floor(min / 34); i <= Math.floor(max / 34); i++)
		  {
		  	for (var j = Math.min(min % 34, max % 34); j <= Math.max(min % 34, max % 34); j++)
		  	{
		  		document.getElementById("Square"+ (i * 34 + j).toString()).__data__.fill = mousing;
		  		select_square.push([i ,j]);
		  	}
		  }
		  border.call(redraw);
		  mousing = 0;
		  console.log(select_square);
		}

		function redraw(border) {
		  border.attr("d", path(topojson.mesh(topology, topology.objects.hexagons, function(a, b) { return a.fill ^ b.fill; })));
		}

		function hexTopology(radius, width, height) {
			var dx = radius * 1.5,// * Math.sin(Math.PI / 3),
				dy = radius * 1.5,
				m = 34,
				n = 30,
				geometries = [],
				arcs = [];

			for (var j = -1; j <= m; ++j) {
				for (var i = -1; i <= n; ++i) {
					var y = j + 1.35, x = i;
					arcs.push([[x, y - 1], [1, 0]], [[x + 1, y - 1], [0, 1]], [[x + 1, y], [-1, 0]]);
				}
			}

			for (var j = 0, q = 3; j < m; ++j, q += 6) {
				for (var i = 0; i < n; ++i, q += 3) {
					geometries.push({
						type: "Polygon",
						arcs: [[q, q + 1, q + 2, ~(q + (n + 2) * 3), ~(q - 2), ~(q - (n + 2) * 3 + 2)]],
						fill: 0,
						value: color_arr[i*34+j].value,
						x_axis: i,
						y_axis: j
					});
				}
			}

			return {
				transform: {translate: [0, 0], scale: [2, 2]},
				objects: {hexagons: {type: "GeometryCollection", geometries: geometries}},
				arcs: arcs
			};
		}

		function hexProjection(radius) {
		  var dx = radius * 1.5,
		      dy = radius * 1.5;
		  return {
		    stream: function(stream) {
		      return {
		        point: function(x, y) { stream.point(x * dx / 2, (y - (2 - (y & 1)) / 3) * dy / 2); },
		        lineStart: function() { stream.lineStart(); },
		        lineEnd: function() { stream.lineEnd(); },
		        polygonStart: function() { stream.polygonStart(); },
		        polygonEnd: function() { stream.polygonEnd(); }
		      };
		    }
		  };
		}

		function change(){
			var bean = document.getElementById("beans");
			bean.onmousemove = function(){
				var value = bean.value;
				heatmap(value);
			}
		}

		function heatmap(value){
			var num = 0;

		  	var time = 0;

		  	for (var key in count[value])
		  	{
		  		if (key != "time")
		  		{
		  			color_arr[parseInt(sid[num].x_axis) * 34 + parseInt(sid[num].y_axis)].value = count[value][key];
		  		}
		  		num++;
		  	}

		  	var topology = hexTopology(radius, width, height);

			d3.select("#heatmap")
				  .selectAll("path")
				  .data(topology.objects.hexagons.geometries)
				  .attr("d", function(d) { return path(topojson.feature(topology, d)); })
				  .style("fill", function(d) { return myColor(d.value)} )
				    //.attr("class", function(d) { return d.fill ? "fill" : null; })
				  .on("mousedown", mousedown)
				  //.on("mousemove", mousemove)
				  .on("mouseup", mouseup);
		}
	})
})


		

</script>
</body>